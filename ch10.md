# Chapter 10

## Stacks & Queues
- stack: LIFO   
- queue: FIFO
- deque
- use two stacks (resp. queues) to implement a queue (resp. stack)    
`one for push in, the other is only needed when we need to pop out. Average complexity should be O(1), worst case around O(n)`        `for the resp. one, enqueue needs O(1), dequeue needs O(n)???`
	

## Linked lists
- sentinels
- reverse a linked list

 	  next = node->next;
	  node->next = prev;
	  prev = node;
	  node = next;


`why the answer of 10.2-1 is no, why need to go through all the nodes?`    
`10.2-4 set the key of the nil as the searching key?`    
`10.2-5 all O(n)?`    
**THE BEST SOLUTION FOR THE INVERSE (10.2-8)**


## Pointers
allocate / free objects
compact list

- compactify  `10.3-5??`
- search in $O(\sqrt(n))$ ??

## Rooted trees
binary tree
tree with unbounded branching: left-child, right-sibling

---
***
***
***
***
***
***
***
***
	I can build a rectangle with just lines :)